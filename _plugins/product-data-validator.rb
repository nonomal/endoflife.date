# Verify product data by performing some validation before and after products are enriched.
# Note that the site build is stopped if the validation fails.
#
# The validation done before enrichment is the validation of the properties set by the users.
#
# The validation done after enrichment is mainly the validation of URLs, because lots of URLs are
# generated by the changelogTemplate. Note that this validation is not done by default because it
# takes a lot of time. You can activate it by setting the MUST_CHECK_URL environment variable to
# true before building the site.

require 'jekyll'
require "open-uri"

module EndOfLifeHooks
  VERSION = '1.0.0'
  TOPIC = "Product Validator:"
  VALID_CATEGORIES = [
    "app",
    "db",
    "device",
    "framework",
    "lang",
    "os",
    "server-app",
    "service",
    "standard",
  ]

  # Global error count
  @@error_count = 0

  def self.increase_error_count
    @@error_count += 1
  end

  def self.error_count
    @@error_count
  end

  def self.validate(product)
    start = Time.now
    Jekyll.logger.debug TOPIC, "Validating '#{product.name}'..."

    error_if = Validator.new(product, product.data)
    error_if.is_not_a_string('title')
    error_if.is_not_in('category', EndOfLifeHooks::VALID_CATEGORIES)
    error_if.does_not_match('permalink', /^\/[a-z0-9-]+$/)
    error_if.does_not_match('alternate_urls', /^\/[a-z0-9-_]+$/)
    error_if.is_not_a_string('versionCommand') if product.data.has_key?('versionCommand')
    error_if.is_not_an_url('releasePolicyLink') if product.data.has_key?('releasePolicyLink')
    error_if.is_not_an_url('releaseImage') if product.data.has_key?('releaseImage')
    error_if.is_not_an_url('changelogTemplate') if product.data.has_key?('changelogTemplate')
    error_if.is_not_a_string('releaseLabel') if product.data.has_key?('releaseLabel')
    error_if.is_not_a_string('LTSLabel')
    error_if.is_not_a_boolean_nor_a_string('eolColumn')
    error_if.is_not_a_number('eolWarnThreshold')
    error_if.is_not_a_boolean_nor_a_string('activeSupportColumn')
    error_if.is_not_a_number('activeSupportWarnThreshold')
    error_if.is_not_a_boolean_nor_a_string('releaseColumn')
    error_if.is_not_a_boolean_nor_a_string('releaseDateColumn')
    error_if.is_not_a_boolean_nor_a_string('discontinuedColumn')
    error_if.is_not_a_number('discontinuedWarnThreshold')
    error_if.is_not_a_boolean_nor_a_string('extendedSupportColumn')
    error_if.is_not_a_number('extendedSupportWarnThreshold')
    error_if.is_not_an_array('auto')
    error_if.is_not_an_array('identifiers')
    error_if.is_not_an_array('releases')

    for release in product.data['releases']
      error_if = Validator.new(product, release)
      error_if.is_not_a_string('releaseCycle')
      error_if.is_not_a_string('releaseLabel') if release.has_key?('releaseLabel')
      error_if.is_not_a_string('codename') if release.has_key?('codename')
      error_if.is_not_a_date('releaseDate') if product.data['releaseDateColumn']
      error_if.is_not_a_boolean_nor_a_date('support') if product.data['activeSupportColumn']
      error_if.is_not_a_boolean_nor_a_date('eol') if product.data['eolColumn']
      error_if.is_not_a_boolean_nor_a_date('discontinued') if product.data['discontinuedColumn']
      error_if.is_not_a_boolean_nor_a_date('extendedSupport') if product.data['extendedSupportColumn']
      error_if.is_not_a_boolean_nor_a_date('lts') if product.data.has_key?('lts')
      error_if.is_not_a_string('latest') if product.data['releaseColumn']
      error_if.is_not_a_date('latestReleaseDate') if product.data['releaseColumn'] and product.data.has_key?('latestReleaseDate')
      error_if.is_not_an_url('link') if product.data['link']
    end

    Jekyll.logger.debug TOPIC, "Product '#{product.name}' successfully validated in #{(Time.now - start).round(3)} seconds."
  end

  def self.validate_urls(product)
    if ENV.fetch('MUST_CHECK_URL', false)
      start = Time.now
      Jekyll.logger.info TOPIC, "Validating urls for '#{product.name}'..."

      error_if = Validator.new(product, product.data)
      error_if.is_url_invalid('releasePolicyLink') if product.data['releasePolicyLink']
      error_if.is_url_invalid('releaseImage') if product.data['releaseImage']
      error_if.is_url_invalid('iconUrl') if product.data['iconUrl']

      for release in product.data['releases']
        error_if = Validator.new(product, release)
        error_if.is_url_invalid('link') if release['link']
      end

      Jekyll.logger.info TOPIC, "Product '#{product.name}' urls successfully validated in #{(Time.now - start).round(3)} seconds."
    end
  end

  private

  class Validator
    def initialize(product, data)
      @product = product
      @data = data
      @error_count = 0
    end

    def error_count
      @error_count
    end

    def is_not_an_array(property)
      value = @data[property]
      if not value.kind_of?(Array)
        declare_error(property, value, "expecting and Array, got #{value.class}")
      end
    end

    def is_not_in(property, valid_values)
      value = @data[property]
      if not valid_values.include?(value)
        declare_error(property, value, "expecting one of #{valid_values.join(', ')}")
      end
    end

    def does_not_match(property, regex)
      values = @data[property].kind_of?(Array) ? @data[property] : [@data[property]]
      for value in values
        if not regex.match?(value)
          declare_error(property, value, "should match #{regex}")
        end
      end
    end

    def is_not_a_string(property)
      value = @data[property]
      if not value.kind_of?(String)
        declare_error(property, value, "expecting a value of type String, got #{value.class}")
      end
    end

    def is_not_an_url(property)
      does_not_match(property, /^https?:\/\/.+$/)
    end

    def is_not_a_date(property)
      value = @data[property]
      if not value.respond_to?(:strftime)
        declare_error(property, value, "expecting a value of type boolean or date, got #{value.class}")
      end
    end

    def is_not_a_number(property)
      value = @data[property]
      if not value.kind_of?(Numeric)
        declare_error(property, value, "expecting a value of type numeric, got #{value.class}")
      end
    end

    def is_not_a_boolean_nor_a_date(property)
      value = @data[property]
      if not ([true, false].include?(value) or value.respond_to?(:strftime))
        declare_error(property, value, "expecting a value of type boolean or date, got #{value.class}")
      end
    end

    def is_not_a_boolean_nor_a_string(property)
      value = @data[property]
      if not ([true, false].include?(value) or value.kind_of?(String))
        declare_error(property, value, "expecting a value of type boolean or string, got #{value.class}")
      end
    end

    def is_url_invalid(property)
      # strip is necessary because changelogTemplate is sometime reformatted on two lines by latest.py
      url = @data[property].strip
      user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0'

      URI.open(url, 'User-Agent' => user_agent, :open_timeout => 3, :read_timeout => 5) do |response|
        if response.status[0].to_i >= 300
          declare_error(property, url, "got an HTTP response code #{response.status}")
        end
      end
    rescue StandardError => e
      declare_error(property, url, "got an error : '#{e}'")
    end

    def declare_error(property, value, details)
      location = @data.has_key?('releaseCycle') ? "#{@product.name}##{@data['releaseCycle']}" : @product.name
      Jekyll.logger.error TOPIC, "Invalid #{property} '#{value}' for #{location}, #{details}."
      EndOfLifeHooks::increase_error_count()
    end
  end
end

# Must be run before enrichment, hence the high priority.
Jekyll::Hooks.register :pages, :post_init, priority: Jekyll::Hooks::PRIORITY_MAP[:high] do |page, payload|
  if page.data['layout'] == 'product'
    EndOfLifeHooks::validate(page)
  end
end

# Must be run after enrichment, hence the low priority.
Jekyll::Hooks.register :pages, :post_init, priority: Jekyll::Hooks::PRIORITY_MAP[:low] do |page, payload|
  if page.data['layout'] == 'product'
    EndOfLifeHooks::validate_urls(page)
  end
end

# Must be run at the end of all validation
Jekyll::Hooks.register :site, :post_render, priority: Jekyll::Hooks::PRIORITY_MAP[:low] do |site, payload|
  if EndOfLifeHooks::error_count > 0
    raise "Site build canceled : #{EndOfLifeHooks::error_count} errors detected"
  end
end
